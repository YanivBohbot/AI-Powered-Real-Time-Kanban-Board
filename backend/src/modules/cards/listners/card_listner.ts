import { Injectable, Logger } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ConfigService } from '@nestjs/config';
import { ChatOpenAI } from '@langchain/openai';
import { SystemMessage, HumanMessage } from '@langchain/core/messages';
import { z } from 'zod';
import { EventsGateway } from '../../../events/event.gateway';
import { CardCreatedEvent } from '../events/card-created.events';
import { Card } from '../entities/cards.entity';

@Injectable()
export class CardListener {
  private readonly logger = new Logger(CardListener.name);
  private readonly model: ChatOpenAI;

  constructor(
    @InjectRepository(Card)
    private cardsRepository: Repository<Card>,
    private configService: ConfigService,
    private eventsGateway: EventsGateway, // üëà 2. Inject the Gateway
  ) {
    this.model = new ChatOpenAI({
      openAIApiKey: this.configService.get<string>('OPENAI_API_KEY'),
      modelName: 'gpt-4o',
      temperature: 0.7,
    });
  }

  @OnEvent('card.created') // ‚ö†Ô∏è Ensure this string matches what you emit in CardsService
  async handleCardCreatedEvent(payload: CardCreatedEvent) {
    // üõë 1. Safety Brake
    if (
      !payload.description ||
      payload.description.includes('Generated by AI')
    ) {
      return;
    }

    this.logger.log(`ü§ñ ARCHITECT AGENT: analyzing "${payload.title}"...`);

    try {
      // 2. Define Blueprint
      const subtaskSchema = z.object({
        subtasks: z
          .array(z.string())
          .describe('A list of 3-5 actionable subtasks.'),
        summary: z.string().describe('A 1-sentence summary of the main task.'),
      });

      // 3. Call AI
      const structuredLlm = this.model.withStructuredOutput(subtaskSchema);
      const response = await structuredLlm.invoke([
        new SystemMessage(
          'You are an expert Technical Project Manager. Break down the task.',
        ),
        new HumanMessage(
          `Task: ${payload.title}\nContext: ${payload.description}`,
        ),
      ]);

      // 4. Update Parent Summary
      await this.cardsRepository.update(payload.cardId, {
        aiSummary: response.summary,
      });

      this.logger.log(
        `ü§ñ ARCHITECT AGENT: Creating ${response.subtasks.length} subtasks...`,
      );

      // üõ†Ô∏è 5. Fetch Parent + Board (Crucial for WebSockets)
      const parentCard = await this.cardsRepository.findOne({
        where: { id: payload.cardId },
        relations: ['list', 'list.board'], // üëà Must load 'list.board' to get the Board ID
      });

      if (parentCard && parentCard.list) {
        for (const subtaskTitle of response.subtasks) {
          // Create the entity
          const newCard = this.cardsRepository.create({
            title: `[AI] ${subtaskTitle}`,
            description: 'Generated by AI Architect',
            priority: 'LOW',
            list: parentCard.list,
            order: parentCard.order + 1,
          });

          // Save to DB
          const savedCard = await this.cardsRepository.save(newCard);

          // üëá 6. THE MISSING LINK: Broadcast to Frontend!
          this.eventsGateway.server.emit('card-created', {
            ...savedCard,
            boardId: parentCard.list.board.id, // Frontend needs this to know where to put it
          });

          // Optional: Tiny delay for "Pop-in" visual effect (looks cooler)
          await new Promise((resolve) => setTimeout(resolve, 500));
        }
      }

      this.logger.log(`‚úÖ ARCHITECT AGENT: Finished breakdown.`);
    } catch (error: any) {
      this.logger.error('‚ùå ARCHITECT AGENT: Failed.', error);
    }
  }
}
